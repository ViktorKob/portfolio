package net.thomas.portfolio.hbase_index.schema;

import static net.thomas.portfolio.common.utils.ToStringUtil.asString;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_COMMUNICATION_ENDPOINT;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_CONVERSATION;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_DISPLAYED_NAME;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_DOMAIN;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_EMAIL;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_EMAIL_ADDRESS;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_EMAIL_ENDPOINT;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_LOCALNAME;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_PRIVATE_ID;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_PUBLIC_ID;
import static net.thomas.portfolio.hbase_index.schema.TestSampleData.SOME_TEXT_MESSAGE;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

import org.junit.Test;

public class AutoGeneratedEntityMethodsUnitTest {
	private static final int ONE_FOR_THE_UID = 1;
	private static final String SOME_STRING = "Some string";
	private static final Entity[] ENTITIES_UNDER_TEST = { SOME_LOCALNAME, SOME_DISPLAYED_NAME, SOME_PUBLIC_ID, SOME_PRIVATE_ID, SOME_DOMAIN, SOME_EMAIL_ADDRESS,
			SOME_EMAIL_ENDPOINT, SOME_COMMUNICATION_ENDPOINT, SOME_EMAIL, SOME_TEXT_MESSAGE, SOME_CONVERSATION };

	@Test
	public void shouldCalculateHashCode() {
		runTestOnAllEntities((entity) -> {
			assertNotEquals("Calculation of hashcode for entity returned zero for " + entity, 0, entity.hashCode());
		});
	}

	@Test
	public void shouldCalculateHashCodeWithNullField() {
		runTestOnAllEntities((entity) -> {
			for (final Field field : getFields(entity)) {
				if (!"uid".equals(field.getName())) {
					assertInstanceWithFieldAsNullCanCalculateHashCode(entity, field);
				}
			}
		});
	}

	@Test
	public void shouldBeEqualToItself() {
		runTestOnAllEntities((entity) -> {
			assertTrue("Comparisson of entity to itself had unexpected outcome for " + entity, entity.equals(entity));
		});
	}

	@Test
	public void shouldNotBeEqualToNull() {
		runTestOnAllEntities((entity) -> {
			assertFalse("Comparisson of entity to null had unexpected outcome for " + entity, entity.equals(null));
		});
	}

	@Test
	@SuppressWarnings("unlikely-arg-type")
	public void shouldNotBeEqualToDifferentObject() {
		runTestOnAllEntities((entity) -> {
			assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, entity.equals(SOME_STRING));
		});
	}

	@Test
	public void shouldNotEqualToCopyOfItselfWithNullField() {
		runTestOnAllEntities((entity) -> {
			for (final Field field : getFields(entity)) {
				if (!"uid".equals(field.getName())) {
					assertNewInstanceWithFieldAsNullIsNotEqualToOriginal(entity, field);
				}
			}
		});
	}

	private void assertInstanceWithFieldAsNullCanCalculateHashCode(Entity entity, Field field)
			throws InstantiationException, IllegalAccessException, InvocationTargetException {
		final Entity newInstance = createNewInstanceWithFieldSetToNull(entity, field);
		assertNotEquals("Calculation of hashcode for entity returned zero for " + entity, 0, newInstance.hashCode());
	}

	private void assertNewInstanceWithFieldAsNullIsNotEqualToOriginal(Entity entity, Field field)
			throws InstantiationException, IllegalAccessException, InvocationTargetException {
		final Object[] arguments = buildArgumentListWithSpecifiedFieldAsNull(entity, field);
		final Constructor<?> constructor = getFirstConstructor(entity);
		final Entity newInstance1 = (Entity) constructor.newInstance(arguments);
		final Entity newInstance2 = (Entity) constructor.newInstance(arguments);
		assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, entity.equals(newInstance1));
		assertFalse("Comparisson of entity to different object type had unexpected outcome for " + entity, newInstance1.equals(entity));
		assertTrue("Comparisson of entity to different object type had unexpected outcome for " + entity, newInstance1.equals(newInstance2));
	}

	private Object[] buildArgumentListWithSpecifiedFieldAsNull(Entity entity, Field field) throws IllegalAccessException {
		final Object[] arguments = new Object[getFields(entity).length - ONE_FOR_THE_UID];
		int argument = 0;
		for (final Field entityField : getFields(entity)) {
			if (entityField.equals(field)) {
				if (isArray(field)) {
					arguments[argument++] = Array.newInstance(getComponentType(field), 0);
				} else {
					arguments[argument++] = null;
				}
			} else if ("uid".equals(entityField.getName())) {
				;// The uid is not part of any constructor
			} else {
				arguments[argument++] = entityField.get(entity);
			}
		}
		return arguments;
	}

	@Test
	public void shouldContainAllFieldsInStringRepresentation() {
		runTestOnAllEntities((entity) -> {
			final String entityAsString = entity.toString();
			for (final Field field : getFields(entity)) {
				assertValueForFieldIsPresentInString(entity, field, entityAsString);
			}
		});
	}

	private Entity createNewInstanceWithFieldSetToNull(Entity entity, Field field)
			throws IllegalAccessException, InstantiationException, InvocationTargetException {
		final Object[] arguments = buildArgumentListWithSpecifiedFieldAsNull(entity, field);
		final Constructor<?> constructor = getFirstConstructor(entity);
		return (Entity) constructor.newInstance(arguments);
	}

	private void assertValueForFieldIsPresentInString(Object entity, final Field field, final String unitAsString) throws IllegalAccessException {
		final String expectedValue = getFieldAsString(field, entity);
		final String message = "Unable to find expected value " + expectedValue + " for field " + field.getName() + " in entity " + entity;
		assertTrue(message, unitAsString.contains(expectedValue));
	}

	private String getFieldAsString(final Field field, Object entity) throws IllegalAccessException {
		final Object value = field.get(entity);
		if (isArray(field)) {
			final String asString = asString(value);
			return asString.substring(1, asString.length() - 2);
		} else {
			return value.toString();
		}
	}

	private void runTestOnAllEntities(TestRunner runner) {
		for (final Entity entity : ENTITIES_UNDER_TEST) {
			try {
				runner.executeOn(entity);
			} catch (final Throwable t) {
				throw new RuntimeException("Failed testing " + entity, t);
			}
		}
	}

	@FunctionalInterface
	private static interface TestRunner {
		void executeOn(Entity entity) throws IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException;
	}

	private Field[] getFields(Entity entity) {
		return entity.getClass()
			.getFields();
	}

	private Class<?> getComponentType(Field field) {
		return field.getType()
			.getComponentType();
	}

	private Constructor<?> getFirstConstructor(Entity entity) {
		return entity.getClass()
			.getDeclaredConstructors()[0];
	}

	private boolean isArray(Field field) {
		return field.getType()
			.isArray();
	}
}
